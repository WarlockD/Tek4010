/*
 * tek4010.c
 * 
 * A tek 4010 graphics emulator
 * 
 * Copyright 2016,2019  rricharz
 * 
 */

#define MEM 128

#define TODO 4          // for speed reasons, draw TODO small vectors until screen updates

#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <errno.h>

#include "main.h"
#include "tek4010.h"

static int counter = 0;
static int memx1[MEM], memy1[MEM], memx2[MEM], memy2[MEM];
static float memv[MEM]; 

static int count = 0;
static int mode;
static int x0,y0,x2,y2;

FILE *getData;
int filedes[2];         // the file descriptors of the pipes

int getk()
// get a char, if available, otherwise return -1
{
        static int initialized = 0;
        char *argv[4];
        
        if (!initialized) {
                
                // create pipes for communication between parent and child
                if (pipe(filedes) == -1) {
                        printf("Cannot initialize pipes\n");
                        exit(1);
                }
                
                // now fork a child process
                pid_t pid = fork();
                if (pid == -1) {
                        printf("Cannot fork child process\n");
                        exit(1);
                }
                else if (pid == 0) {  // child process
                        // prepare capturing stdout of child process
                        while ((dup2(filedes[1], STDOUT_FILENO) == -1) && (errno == EINTR)) {}
                        close(filedes[1]);
                        close(filedes[0]);
                        argv[0] = "rsh";
                        argv[1] = "-l";
                        argv[2] = "rene";
                        argv[3]= "pdp11";
                        execl("/usr/bin","rsh",argv);
                        printf("Cannot execute rsh\n");
                        exit(1);
                }
                
                exit(1);
                
                getData = popen("rsh -l rene pdp11", "r");
                if (getData == 0) {
                        printf("cannot execute rsh\n");
                        exit(1);
                }
                else printf("rsh is running\n");
                
                // use termios to turn off line buffering
                struct termios term;
                tcgetattr(fileno(getData), &term);
                term.c_lflag &= ~ICANON ;
                tcsetattr(fileno(getData), TCSANOW,&term);
                setbuf(getData,0);
                initialized = 1;
        }
        
        int bytesWaiting;
        ioctl(fileno(getData), FIONREAD, &bytesWaiting);
        if (bytesWaiting > 0)
                return getc(getData);
        else
                return -1;
}

void tek4010_init()
// put any code here to initialize the tek4010
{
	counter = 0;         // example
        x0 = 0;
        y0 = WINDOW_HEIGHT - WINDOW_HEIGHT / 36;
}

int tek4010_on_timer_event()
// if TIMER_INTERVAL in tek4010.h is larger than zero, this function
// is called every TIMER-INTERVAL milliseconds
// if the function returns 1, the window is redrawn by calling applicatin_draw
{
	return 1;
}
 
int tek4010_clicked(int button, int x, int y)
// is called if a mouse button is clicked in the window
// button = 1: means left mouse button; button = 3 means right mouse button
// x and y are the coordinates
// if the function returns 1, the window is redrawn by calling applicatin_draw
{
	return 1;
}

void tek4010_quit()
// is called if the main window is called bevore the tek4010 exits
// put any code here which needs to be called on exit
{
        pclose(getData);
}



void tek4010_draw(cairo_t *cr, cairo_t *cr2, int width, int height, int first)
// draw onto the main window using cairo
// width is the actual width of the main window
// height is the actual height of the main window
// surface1 is used for persistent drawing, surface2 for faiding drawing 

{		
        int ch;
        int todo;
        char s[2];
        
        if (first) { // first surface is only cleared to black once
                cairo_set_source_rgb(cr, 0, 0, 0);
                cairo_paint(cr);
                
                for (int i=0; i<MEM; i++) {
                        memx1[i]=2;
                        memy1[i]=i * (WINDOW_HEIGHT/MEM); 
                        memx2[i]=100;
                        memy2[i]=i * (WINDOW_HEIGHT/MEM);
                        memv[i]=0;
                }
        }
        cairo_set_source_rgba(cr2, 0, 0, 0, 0); // second surface is cleared each time
        cairo_set_operator(cr2, CAIRO_OPERATOR_SOURCE);
        cairo_paint(cr2);
        cairo_set_operator(cr2, CAIRO_OPERATOR_OVER);
        cairo_set_line_width (cr2, 3);
        cairo_set_source_rgb(cr2, 1, 1, 1);
        
        cairo_set_antialias(cr, CAIRO_ANTIALIAS_BEST);      
	cairo_set_line_width (cr, 1);
        cairo_set_source_rgb(cr, 0, 0.8, 0);
        
        cairo_select_font_face(cr, "Monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
        cairo_set_font_size(cr, 16);
        cairo_select_font_face(cr2, "Monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
        cairo_set_font_size(cr2, 16);
        
        todo = TODO;
        
        do {
                ch = getk();
                if (ch == 31) {
                        mode = 0;
                        ch = getk();
                }
                if (ch == -1) todo = 0;  // no char available     
                switch (mode) {
                        case 1: y0 = 32 * (ch - 32); mode++; break;
                        case 2: y0 = y0 + ch - 96; mode++; break;
                        case 3: x0 =  32 * (ch - 32); mode++; break;
                        case 4: x0 = x0 + ch - 64; mode++; break;
                        case 5: y2 = 32 * (ch - 32); mode++; break;
                        case 6: y2 = y2 + ch - 96; mode++; break;
                        case 7: x2 =  32 * (ch - 32); mode++; break;
                        case 8: x2 = x2 + ch - 64; mode++; break;
                        case 9: cairo_move_to(cr, x0, WINDOW_HEIGHT - y0);
                                cairo_line_to(cr, x2, WINDOW_HEIGHT - y2);
                                cairo_stroke (cr);                        
                                cairo_move_to(cr2, x0, WINDOW_HEIGHT - y0);
                                cairo_line_to(cr2, x2, WINDOW_HEIGHT - y2);
                                cairo_stroke (cr2);
                                
                                // for speed reasons, do not update screen right away
                                // if many very small verctors are drawn
                                todo--;
                                if ((x2-x0) > TODO) todo = 0;
                                if ((x0-x2) > TODO) todo = 0;
                                if ((y2-y0) > TODO) todo = 0;
                                if ((y0-y2) > TODO) todo = 0;
                                
                                mode = 0;
                                break;
                        case 10:                        // handle escape modes
                                switch (ch) {
                                case 12:cairo_set_source_rgb(cr, 0, 0.0, 0);
                                        cairo_paint(cr);
                                        cairo_set_source_rgb(cr, 0, 0.8, 0);
                                        x0 = 0;
                                        y0 = WINDOW_HEIGHT - WINDOW_HEIGHT / 36;                                               
                                }
                                mode = 0;
                                break;
                        default:switch (ch) {
                                case 0:  return; break;
                                case EOF: return; break;
                                case 9:  x0 = x0 + 1 - (x0 % (8 * WINDOW_WIDTH / 74)) + 8* WINDOW_WIDTH / 74 - 1;
                                         break;
                                case 10: y0 -= WINDOW_HEIGHT / 36; x0 = 0;
                                         if (y0 < 10) y0 = WINDOW_HEIGHT - WINDOW_HEIGHT / 36; 
                                         break;
                                case 13: mode = 0; todo = 0; x0 = 0; break;
                                case 27: mode = 10; break; // escape mode
                                case 29: mode = 1; break;
                                default:
                                        if ((ch >= 32) && (ch <=127)) { // printable character
                                                s[0] = ch;
                                                s[1] = 0;
                                                cairo_move_to(cr, x0, WINDOW_HEIGHT - y0);
                                                cairo_show_text(cr, s);
                                                cairo_move_to(cr2, x0, WINDOW_HEIGHT - y0);
                                                cairo_show_text(cr2, s);
                                                x0 += WINDOW_WIDTH / 74;
                                                todo--;
                                        }
                                        break;
                                }
                                break;                                
                }
        }
        while (todo);
}
